---
title: "React18の動作確認【Automatic Batchig】"
emoji: "🎃"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["React", "javascript"]
published: true
---

# はじめに

今回は React18 の新機能`Automatic Batchig`について React17 と React18 それぞれの動作の違いについて確認していきたいと思います。

# Automatic Batching とは？

> React 18 では、デフォルトでより多くのバッチ処理を実行することで、すぐに使用できるパフォーマンスの向上が追加されています。バッチ処理とは、パフォーマンスを向上させるために、React が複数の状態更新を 1 つの再レンダリングにグループ化することです。React 18 より前は、React イベント ハンドラー内で更新をバッチ処理するだけでした。Promise、setTimeout、ネイティブ イベント ハンドラー、またはその他のイベント内の更新は、デフォルトでは React でバッチ処理されませんでした。

(引用元：[https://react.dev/blog/2022/03/08/react-18-upgrade-guide#automatic-batching](https://react.dev/blog/2022/03/08/react-18-upgrade-guide#automatic-batching))

Automatic Batching とは、複数の setState などが呼ばれた場合に、一度のレンダリングでまとめて処理するようになった機能です。
React17 までは、関数内でのみバッジ処理が行われていましたが、React18 からは、関数外でもバッジ処理が行われるようになりました。
promise や setTimeout、ネイティブイベントハンドラーなどの関数外での処理もバッジ処理が行われるようになったことで、パフォーマンスが向上しました。

まずは React17 でも行われてる関数内でのバッジ処理を確認していきたいと思います。

:::message
今回は動作確認をしやすくするために Strict モードを無効にしています。
:::

## 関数内でのバッジ処理

更新ボタンをクリックすると、コンソールに foo の値が 2 回出力されるコンポーネントです。

```tsx:EventHandler.tsx
import { useState } from "react";

const EventHandler = () => {
  console.log("EventHandlerコンポーネントがレンダリングされました！");
  const [foo, setFoo] = useState<number>(0);
  const [bar, setBar] = useState<number>(0);

  const countUp = () => {
    console.log(foo);
    setFoo((prev) => prev + 1);
    console.log(foo);
    setBar((prev) => prev + 1);
  };

  return (
    <div className="mt-8">
      <p className="text-center">イベントハンドラ内の処理</p>
      <div className="mt-6 text-center">
        <div className="flex justify-center gap-5">
          <p>foo: {foo}</p>
          <p>bar: {bar}</p>
        </div>
        <button
          className="bg-slate-600 text-white py-2 px-5 mt-5"
          onClick={countUp}
        >
          更新
        </button>
      </div>
    </div>
  );
};

export default EventHandler;


```

### 実行結果

コンソールを確認してみると、以下のようになりました。
ボタンをクリックすると、2 回同じ値が出力されたあとにコンポーネントが再レンダリングされていることが確認できます。
これによって、setState がバッチ処理（１つにまとめられている）ことがわかります。
バッジ処理が行われていない場合は、setState の記述を増やした分だけコンポーネントが再レンダリングされてしまうため、パフォーマンス低下につながります。
![](https://storage.googleapis.com/zenn-user-upload/689f9f432dca-20230917.gif)

## 関数外でのバッジ処理（React18 新機能）

関数外でのバッジ処理は React18 からの新機能です。
fetch で [jsonplaceholder](https://jsonplaceholder.typicode.com/) からデータを取得して表示するコンポーネントで確認していきたいと思います。
バッチ処理が行われているか確認するため、分かりやすいように`setIsVisible((prev) => !prev);`を 3 つに増やして、React17 と React18 での挙動の違いを確認していきたいと思います。

```tsx:EventHandler.tsx
import { useState } from "react";

type TodoType = {
  userId: number;
  id: number;
  title: string;
  completed: boolean;
};

const Other = () => {
  console.log("Otherコンポーネントがレンダリングされました！");
  const [todosData, setTodosData] = useState<TodoType[] | null>(null);
  const [isVisible, setIsVisible] = useState<boolean>(false);

  const fetchApi = async () => {
    const res = await fetch("https://jsonplaceholder.typicode.com/todos");
    const data = await res.json();
    setIsVisible((prev) => !prev);
    setIsVisible((prev) => !prev);
    setIsVisible((prev) => !prev);
    setTodosData(data);
  };

  return (
    <div className="mt-8">
      <p className="text-center">イベントハンドラ以外の処理</p>
      <div className="mt-6 text-center">
        <button
          className="bg-slate-600 text-white py-2 px-5 mt-5"
          onClick={fetchApi}
        >
          API取得
        </button>
        {isVisible && (
          <div className="mt-8">
            {todosData?.map((todo) => (
              <p key={todo.id} className="p-2">
                {todo.title}
              </p>
            ))}
          </div>
        )}
      </div>
    </div>
  );
};

export default Other;


```

### 実行結果

コンソールを確認してみると、以下のようになりました。
React17 では、関数外でのバッジ処理は行われていないため、setState の数だけコンポーネントが再レンダリングされていることがわかります。
一方、React18 では、関数外でもバッジ処理が行われているため、コンポーネントが無駄に再レンダリングされていないことがわかります。

#### React17

![](https://storage.googleapis.com/zenn-user-upload/4d4f1e5659ff-20230917.gif)

#### React18

![](https://storage.googleapis.com/zenn-user-upload/ef5b7f1c6af7-20230917.gif)

# まとめ

React17 と React18 それぞれの関数内バッチ処理と関数外でのバッチ処理の違いを確認してみました。
自動バッチングは普段開発で意識しなくとも有効化されている機能ですが、理解しておくべき機能だと思います。
他にも Transition や Suspense などの機能についても今後確認していきたいです。

# 参考文献

https://ja.legacy.reactjs.org/blog/2022/03/29/react-v18.html
https://www.udemy.com/course/react_v18/
